import importlib
import os
import sys
from concurrent.futures import ThreadPoolExecutor
from core.utils import get_exploit_path


class Exploiter:
    def __init__(self, scan_results, target=None, threads=5):
        self.scan_results = scan_results
        self.target = target
        self.threads = threads
        self.exploitation_results = {}
        self.available_exploits = self._load_available_exploits()

    def _load_available_exploits(self):
        """Carga dinámicamente todos los exploits disponibles"""
        exploits = {}
        exploit_path = get_exploit_path()

        # Recorrer las categorías de exploits
        for category in os.listdir(exploit_path):
            category_path = os.path.join(exploit_path, category)
            if os.path.isdir(category_path) and not category.startswith("__"):
                exploits[category] = []

                # Recorrer los exploits en cada categoría
                for exploit_file in os.listdir(category_path):
                    if exploit_file.endswith(".py") and not exploit_file.startswith(
                        "__"
                    ):
                        exploit_name = exploit_file[:-3]  # Quitar la extensión .py
                        module_path = f"modules.exploits.{category}.{exploit_name}"

                        try:
                            # Importar dinámicamente el módulo
                            exploit_module = importlib.import_module(module_path)
                            if hasattr(exploit_module, "Exploit"):
                                # Obtener metadatos del exploit
                                exploit_info = {
                                    "name": exploit_name,
                                    "category": category,
                                    "description": getattr(
                                        exploit_module.Exploit,
                                        "description",
                                        "No description",
                                    ),
                                    "cve": getattr(
                                        exploit_module.Exploit, "cve", "N/A"
                                    ),
                                    "module_path": module_path,
                                }
                                exploits[category].append(exploit_info)
                        except ImportError as e:
                            print(f"Error al cargar el exploit {module_path}: {e}")

        return exploits

    def list_exploits(self, category=None):
        """Lista los exploits disponibles, opcionalmente filtrados por categoría"""
        if category and category in self.available_exploits:
            return self.available_exploits[category]
        return self.available_exploits

    def match_exploits_to_vulnerabilities(self):
        """Encuentra exploits que coincidan con las vulnerabilidades detectadas"""
        matched_exploits = {}

        for host, host_data in self.scan_results.items():
            matched_exploits[host] = []

            # Coincidencia basada en servicios detectados
            for port, port_data in host_data.get("ports", {}).items():
                service = port_data.get("service", "")
                version = port_data.get("version", "")

                # Buscar exploits para este servicio/versión
                for category, exploits in self.available_exploits.items():
                    for exploit in exploits:
                        # Lógica simplificada - en un caso real sería más sofisticada
                        if service.lower() in exploit["description"].lower():
                            matched_exploits[host].append(
                                {
                                    "exploit": exploit,
                                    "target": f"{host}:{port}",
                                    "service": service,
                                    "version": version,
                                }
                            )

            # Coincidencia basada en vulnerabilidades web
            for vuln in host_data.get("web_vulnerabilities", {}).get(
                "vulnerabilities", []
            ):
                vuln_type = vuln.get("type", "")

                # Buscar exploits para esta vulnerabilidad
                for category, exploits in self.available_exploits.items():
                    for exploit in exploits:
                        if vuln_type.lower() in exploit["description"].lower():
                            matched_exploits[host].append(
                                {
                                    "exploit": exploit,
                                    "target": host_data.get(
                                        "web_vulnerabilities", {}
                                    ).get("url", f"http://{host}"),
                                    "vulnerability": vuln,
                                }
                            )

        return matched_exploits

    def run_exploit(self, exploit_info, target):
        """Ejecuta un exploit específico contra un objetivo"""
        try:
            # Importar el módulo del exploit
            module = importlib.import_module(exploit_info["module_path"])
            exploit_class = module.Exploit

            # Instanciar y ejecutar el exploit
            exploit = exploit_class(target)
            result = exploit.run()

            return {
                "exploit": exploit_info["name"],
                "target": target,
                "success": result.get("success", False),
                "details": result.get("details", {}),
                "payload": result.get("payload", None),
            }
        except Exception as e:
            return {
                "exploit": exploit_info["name"],
                "target": target,
                "success": False,
                "error": str(e),
            }

    def run_all_matching_exploits(self):
        """Ejecuta todos los exploits que coinciden con las vulnerabilidades detectadas"""
        matched_exploits = self.match_exploits_to_vulnerabilities()
        all_tasks = []

        # Preparar todas las tareas de explotación
        for host, exploits in matched_exploits.items():
            for exploit_match in exploits:
                all_tasks.append((exploit_match["exploit"], exploit_match["target"]))

        print(f"[*] Ejecutando {len(all_tasks)} exploits potenciales")

        # Ejecutar exploits en paralelo
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            results = list(
                executor.map(lambda x: self.run_exploit(x[0], x[1]), all_tasks)
            )

        # Organizar resultados por host
        for result in results:
            target = result["target"]
            host = target.split(":")[0] if ":" in target else target

            if host not in self.exploitation_results:
                self.exploitation_results[host] = []

            self.exploitation_results[host].append(result)

        return self.exploitation_results

    def run_specific_exploit(self, exploit_name, target):
        """Ejecuta un exploit específico contra un objetivo específico"""
        # Buscar el exploit por nombre
        exploit_info = None
        for category, exploits in self.available_exploits.items():
            for exploit in exploits:
                if exploit["name"] == exploit_name:
                    exploit_info = exploit
                    break
            if exploit_info:
                break

        if not exploit_info:
            return {"error": f"Exploit '{exploit_name}' no encontrado"}

        return self.run_exploit(exploit_info, target)
